<?xml version="1.0" ?>
<SmellBaseline>
  <ManuallySuppressedIssues></ManuallySuppressedIssues>
  <CurrentIssues>
    <ID>ComplexCondition:SemanticTokens.kt$element is KtVariableDeclaration &amp;&amp; (!element.isVar || element.hasModifier(KtTokens.CONST_KEYWORD)) || element is KtParameter</ID>
    <ID>CyclomaticComplexMethod:Completions.kt$private fun indexCompletionItems(file: CompiledFile, cursor: Int, element: KtElement?, index: SymbolIndex, partial: String): Sequence&lt;CompletionItem&gt;</ID>
    <ID>CyclomaticComplexMethod:SemanticTokens.kt$private fun elementToken(element: PsiElement, bindingContext: BindingContext): SemanticToken?</ID>
    <ID>CyclomaticComplexMethod:StringUtils.kt$fun stringDistance(candidate: CharSequence, pattern: CharSequence, maxOffset: Int = 4): Int</ID>
    <ID>EmptyClassBlock:KotlinLSException.kt$KotlinLSException${ }</ID>
    <ID>EmptyFunctionBlock:Logger.kt$JULRedirector${}</ID>
    <ID>EmptyFunctionBlock:LoggingMessageCollector.kt$LoggingMessageCollector${}</ID>
    <ID>ExplicitItLambdaParameter:Hovers.kt${ i, it -&gt; val ret: String if (i == 0) ret = it.substring(it.indexOf("/**") + 3) // get rid of the start comment characters else if (i == split.size - 1) ret = it.substring(it.indexOf("*/") + 2) // get rid of the end comment characters else ret = it.substring(it.indexOf('*') + 1) // get rid of any leading * ret }</ID>
    <ID>ExplicitItLambdaParameter:RenderCompletionItem.kt${ it -&gt; it }</ID>
    <ID>ForbiddenComment:AddMissingImportsQuickFix.kt$AddMissingImportsQuickFix$// TODO: Visibility checker should be less liberal</ID>
    <ID>ForbiddenComment:BackupClassPathResolver.kt$// TODO: Resolve the gradleCaches dynamically instead of hardcoding this path</ID>
    <ID>ForbiddenComment:CompilationEnvironment.kt$CompilationEnvironment$// TODO: KotlinScriptDefinition will soon be deprecated, use</ID>
    <ID>ForbiddenComment:CompilationEnvironment.kt$CompilationEnvironment$// TODO: Use ScriptDefinition.FromLegacyTemplate directly if possible</ID>
    <ID>ForbiddenComment:CompiledFile.kt$CompiledFile$* Looks for a reference expression at the given cursor. * This is currently used by many features in the language server. * Unfortunately, it fails to find declarations for JDK symbols. * [referenceExpressionAtPoint] provides an alternative implementation that can find JDK symbols. * It cannot, however, replace this method at the moment. * TODO: Investigate why this method doesn't find JDK symbols.</ID>
    <ID>ForbiddenComment:Compiler.kt$Compiler$// TODO: Lock at file-level</ID>
    <ID>ForbiddenComment:CompilerClassPath.kt$CompilerClassPath$// TODO: Fetch class path and build script class path concurrently (and asynchronously)</ID>
    <ID>ForbiddenComment:Completions.kt$// TODO: CRLF?</ID>
    <ID>ForbiddenComment:Completions.kt$// TODO: Deal with alias imports</ID>
    <ID>ForbiddenComment:Completions.kt$// TODO: Visibility checker should be less liberal</ID>
    <ID>ForbiddenComment:Imports.kt$// TODO: Lexicographic insertion</ID>
    <ID>ForbiddenComment:JavaElementConverter.kt$JavaElementConverter$// TODO: Break labels</ID>
    <ID>ForbiddenComment:JavaElementConverter.kt$JavaElementConverter$// TODO: Nullability</ID>
    <ID>ForbiddenComment:JavaElementConverter.kt$JavaElementConverter$// TODO: Type parameters, annotations, modifiers, ...</ID>
    <ID>ForbiddenComment:JavaElementConverter.kt$JavaElementConverter$// TODO: Varargs, ...</ID>
    <ID>ForbiddenComment:JdkSourceArchiveProvider.kt$JdkSourceArchiveProvider$* Checks if the given path is inside the JDK. If it is, we return the corresponding source zip. * Note that this method currently doesn't take into the account the JDK version, which means JDK source code * is only available for JDK 9+ builds. * TODO: improve this resolution logic to work for older JDK versions as well.</ID>
    <ID>ForbiddenComment:KotlinTextDocumentService.kt$KotlinTextDocumentService$// TODO: Investigate when to recompile</ID>
    <ID>ForbiddenComment:OverrideMembers.kt$// TODO: any way can repeat less code between this and the getAbstractMembersStubs in the ImplementAbstractMembersQuickfix?</ID>
    <ID>ForbiddenComment:OverrideMembers.kt$// TODO: does not seem to handle the implicit Any and Object super types that well. Need to find out if that is easily solvable. Finds the methods from them if any super class or interface is present</ID>
    <ID>ForbiddenComment:OverrideMembers.kt$// TODO: look further into this</ID>
    <ID>ForbiddenComment:OverrideMembers.kt$// TODO: look into this</ID>
    <ID>ForbiddenComment:OverrideMembers.kt$// TODO: see where this should ideally be placed</ID>
    <ID>ForbiddenComment:SemanticTokens.kt$// TODO: Ideally we would like to cut-off subtrees outside our range, but this doesn't quite seem to work</ID>
    <ID>ForbiddenComment:SourceExclusions.kt$SourceExclusions$// TODO: Read exclusions from gitignore/settings.json/... instead of</ID>
    <ID>ForbiddenComment:SourcePath.kt$SourcePath$// TODO: Investigate the possibility of compiling all files at once, instead of iterating</ID>
    <ID>ForbiddenComment:SourcePath.kt$SourcePath.SourceFile$// TODO: Create PsiFile using the stored language instead</ID>
    <ID>ForbiddenComment:SourcePath.kt$SourcePath.SourceFile$// TODO: Use language?.associatedFileType?.defaultExtension again</ID>
    <ID>ForbiddenComment:Symbol.kt$Symbol$// TODO: Store location (e.g. using a URI)</ID>
    <ID>ForbiddenComment:SymbolIndex.kt$SymbolIndex$// TODO: Extension completion currently only works if the receiver matches exactly,</ID>
    <ID>FunctionOnlyReturningConstant:Example.kt$fun example()</ID>
    <ID>LongMethod:CompilationEnvironment.kt$CompilationEnvironment.&lt;no name provided&gt;.&lt;no name provided&gt;$override fun resolve( scriptContents: ScriptContents, environment: Environment )</ID>
    <ID>LongMethod:SemanticTokens.kt$private fun elementToken(element: PsiElement, bindingContext: BindingContext): SemanticToken?</ID>
    <ID>LongParameterList:CompiledFile.kt$CompiledFile$( val content: String, val parse: KtFile, val compile: BindingContext, val module: ModuleDescriptor, private val sourcePath: Collection&lt;KtFile&gt;, private val classPath: CompilerClassPath, private val isScript: Boolean = false, val kind: CompilationType = CompilationType.DEFAULT )</ID>
    <ID>LongParameterList:SourcePath.kt$SourcePath.SourceFile$( val uri: URI, var content: String, val path: Path? = uri.filePath, var parsed: KtFile? = null, var compiledFile: KtFile? = null, var compiledContext: BindingContext? = null, var module: ModuleDescriptor? = null, val language: Language? = null, val isTemporary: Boolean = false, // A temporary source file will not be returned by .all() var lastSavedFile: KtFile? = null, )</ID>
    <ID>LoopWithTooManyJumpStatements:StringUtils.kt$for (i in 0 until maxOffset) { when { (iCandidate + i) &lt; candidateLength -&gt; { if (candidate[iCandidate + i] == pattern[iPattern]) { iCandidate += i localCommonSubstring++ break@searchWindow } } (iPattern + i) &lt; patternLength -&gt; { if (candidate[iCandidate] == pattern[iPattern + i]) { iPattern += i localCommonSubstring++ break@searchWindow } } else -&gt; break@searchWindow } }</ID>
    <ID>MagicNumber:BackupClassPathResolver.kt$3</ID>
    <ID>MagicNumber:ClassContentProvider.kt$ClassContentProvider.&lt;no name provided&gt;$5</ID>
    <ID>MagicNumber:Compiler.kt$3</ID>
    <ID>MagicNumber:Compiler.kt$5</ID>
    <ID>MagicNumber:CompilerClassPath.kt$5</ID>
    <ID>MagicNumber:Hovers.kt$3</ID>
    <ID>MagicNumber:Logger.kt$LogLevel.ALL$100</ID>
    <ID>MagicNumber:Logger.kt$LogLevel.DEEP_TRACE$3</ID>
    <ID>MagicNumber:Logger.kt$LogLevel.NONE$100</ID>
    <ID>MagicNumber:Logger.kt$LogLevel.TRACE$2</ID>
    <ID>MagicNumber:Logger.kt$Logger$10</ID>
    <ID>MagicNumber:MavenClassPathResolver.kt$3</ID>
    <ID>MagicNumber:MavenClassPathResolver.kt$4</ID>
    <ID>MagicNumber:MavenClassPathResolver.kt$5</ID>
    <ID>MagicNumber:MavenClassPathResolver.kt$6</ID>
    <ID>MagicNumber:MavenClassPathResolver.kt$MavenClassPathResolver$5</ID>
    <ID>MagicNumber:Server.kt$Server$100</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.CONSTRUCTOR$7</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.ENUM$5</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.ENUM_MEMBER$6</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.FIELD$8</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.MODULE$4</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.UNKNOWN$9</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Kind.VARIABLE$3</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Visibility.PROTECTED$3</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Visibility.PUBLIC$4</ID>
    <ID>MagicNumber:Symbol.kt$Symbol.Visibility.UNKNOWN$5</ID>
    <ID>MagicNumber:URIs.kt$5</ID>
    <ID>MagicNumber:WithStdlibResolver.kt$StdLibItem.Companion$3</ID>
    <ID>MagicNumber:WithStdlibResolver.kt$StdLibItem.Companion$4</ID>
    <ID>MagicNumber:WithStdlibResolver.kt$StdLibItem.Companion$5</ID>
    <ID>MatchingDeclarationName:Main.kt$Args</ID>
    <ID>NestedBlockDepth:Completions.kt$private fun completeMembers(file: CompiledFile, cursor: Int, receiverExpr: KtExpression, unwrapNullable: Boolean = false): Sequence&lt;DeclarationDescriptor&gt;</ID>
    <ID>NestedBlockDepth:KotlinWorkspaceService.kt$KotlinWorkspaceService$override fun didChangeWatchedFiles(params: DidChangeWatchedFilesParams)</ID>
    <ID>NestedBlockDepth:OverrideMembers.kt$private fun parametersMatch( function: KtNamedFunction, functionDescriptor: FunctionDescriptor ): Boolean</ID>
    <ID>NestedBlockDepth:SourcePath.kt$SourcePath$fun save(uri: URI)</ID>
    <ID>NestedBlockDepth:StringUtils.kt$fun stringDistance(candidate: CharSequence, pattern: CharSequence, maxOffset: Int = 4): Int</ID>
    <ID>NewLineAtEndOfFile:Example.kt$.Example.kt</ID>
    <ID>ReturnCount:CompiledFile.kt$CompiledFile$fun referenceAtPoint(cursor: Int): Pair&lt;KtExpression, DeclarationDescriptor&gt;?</ID>
    <ID>ReturnCount:CompiledFile.kt$CompiledFile$fun typeAtPoint(cursor: Int): KotlinType?</ID>
    <ID>ReturnCount:Completions.kt$private fun completeMembers(file: CompiledFile, cursor: Int, receiverExpr: KtExpression, unwrapNullable: Boolean = false): Sequence&lt;DeclarationDescriptor&gt;</ID>
    <ID>ReturnCount:Completions.kt$private fun findPartialIdentifier(file: CompiledFile, cursor: Int): String</ID>
    <ID>ReturnCount:Completions.kt$private fun implicitMembers(scope: HierarchicalScope): Sequence&lt;DeclarationDescriptor&gt;</ID>
    <ID>ReturnCount:Completions.kt$private fun isNotStaticJavaMethod( descriptor: DeclarationDescriptor ): Boolean</ID>
    <ID>ReturnCount:Completions.kt$private fun isNotVisible(target: DeclarationDescriptorWithVisibility, from: DeclarationDescriptor): Boolean</ID>
    <ID>ReturnCount:Completions.kt$private fun isVisible(file: CompiledFile, cursor: Int): (DeclarationDescriptor) -&gt; Boolean</ID>
    <ID>ReturnCount:Completions.kt$private fun subclassParent(target: DeclarationDescriptor, from: DeclarationDescriptor): Boolean</ID>
    <ID>ReturnCount:DefinitionHandler.kt$DefinitionHandler$fun goToDefinition(file: CompiledFile, cursor: Int): Location?</ID>
    <ID>ReturnCount:FindDoc.kt$fun findDoc(declaration: DeclarationDescriptorWithSource): KDocTag?</ID>
    <ID>ReturnCount:FindReferences.kt$private fun possibleReferences(declaration: DeclarationDescriptor, sp: SourcePath): Set&lt;KtFile&gt;</ID>
    <ID>ReturnCount:Hovers.kt$@OptIn(IDEAPluginsCompatibilityAPI::class) private fun renderTypeOf(element: KtExpression, bindingContext: BindingContext): String?</ID>
    <ID>ReturnCount:Hovers.kt$private fun typeHoverAt(file: CompiledFile, cursor: Int): Hover?</ID>
    <ID>ReturnCount:OverrideMembers.kt$private fun parametersMatch( function: KtNamedFunction, functionDescriptor: FunctionDescriptor ): Boolean</ID>
    <ID>ReturnCount:Position.kt$fun location(declaration: DeclarationDescriptor): Location?</ID>
    <ID>ReturnCount:ResolveMain.kt$fun resolveMain(file: CompiledFile): Map&lt;String,Any&gt;</ID>
    <ID>ReturnCount:SemanticTokens.kt$private fun elementToken(element: PsiElement, bindingContext: BindingContext): SemanticToken?</ID>
    <ID>ReturnCount:SignatureHelp.kt$private fun candidates(call: KtCallExpression, file: CompiledFile): List&lt;CallableDescriptor&gt;</ID>
    <ID>ReturnCount:SignatureHelp.kt$private fun isCompatibleWith(call: KtCallExpression, candidate: CallableDescriptor): Boolean</ID>
    <ID>SpreadOperator:Main.kt$(*argv)</ID>
    <ID>SwallowedException:ClassContentProvider.kt$ClassContentProvider$e: FileNotFoundException</ID>
    <ID>SwallowedException:Position.kt$e: NullPointerException</ID>
    <ID>SwallowedException:SourceFiles.kt$SourceFiles$e: FileNotFoundException</ID>
    <ID>SwallowedException:SourceFiles.kt$SourceFiles$e: IOException</ID>
    <ID>SwallowedException:SymbolIndex.kt$SymbolIndex$e: IllegalStateException</ID>
    <ID>TooGenericExceptionCaught:ClassPathResolver.kt$ClassPathResolver$e: Exception</ID>
    <ID>TooGenericExceptionCaught:CompilationEnvironment.kt$CompilationEnvironment$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Completions.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:DefaultClassPathResolver.kt$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Position.kt$e: NullPointerException</ID>
    <ID>TooGenericExceptionCaught:SourcePath.kt$SourcePath$ex: Exception</ID>
    <ID>TooGenericExceptionCaught:SymbolIndex.kt$SymbolIndex$e: Exception</ID>
    <ID>TooGenericExceptionCaught:Utils.kt$e: Exception</ID>
    <ID>TooGenericExceptionThrown:Position.kt$throw RuntimeException("Reached end of file before reaching char $char")</ID>
    <ID>TooGenericExceptionThrown:Position.kt$throw RuntimeException("Reached end of file before reaching line $line")</ID>
    <ID>TooGenericExceptionThrown:Position.kt$throw RuntimeException("Reached end of file before reaching offset $offset")</ID>
    <ID>TooManyFunctions:BackupClassPathResolver.kt$org.javacs.kt.classpath.BackupClassPathResolver.kt</ID>
    <ID>TooManyFunctions:CompiledFile.kt$CompiledFile</ID>
    <ID>TooManyFunctions:Compiler.kt$Compiler : Closeable</ID>
    <ID>TooManyFunctions:CompilerClassPath.kt$CompilerClassPath : Closeable</ID>
    <ID>TooManyFunctions:Completions.kt$org.javacs.kt.completion.Completions.kt</ID>
    <ID>TooManyFunctions:DelegatePrintStream.kt$DelegatePrintStream : PrintStream</ID>
    <ID>TooManyFunctions:ExtractSymbolKind.kt$ExtractSymbolKind : DeclarationDescriptorVisitor</ID>
    <ID>TooManyFunctions:ExtractSymbolVisibility.kt$ExtractSymbolVisibility : DeclarationDescriptorVisitor</ID>
    <ID>TooManyFunctions:FindReferences.kt$org.javacs.kt.references.FindReferences.kt</ID>
    <ID>TooManyFunctions:JavaElementConverter.kt$JavaElementConverter : JavaElementVisitor</ID>
    <ID>TooManyFunctions:JavaTypeConverter.kt$JavaTypeConverter : PsiTypeVisitor</ID>
    <ID>TooManyFunctions:KotlinTextDocumentService.kt$KotlinTextDocumentService : TextDocumentServiceCloseable</ID>
    <ID>TooManyFunctions:Logger.kt$Logger</ID>
    <ID>TooManyFunctions:OverrideMembers.kt$org.javacs.kt.overridemembers.OverrideMembers.kt</ID>
    <ID>TooManyFunctions:RenderCompletionItem.kt$RenderCompletionItem : DeclarationDescriptorVisitor</ID>
    <ID>TooManyFunctions:Server.kt$Server : LanguageServerLanguageClientAwareCloseable</ID>
    <ID>TooManyFunctions:SignatureHelp.kt$org.javacs.kt.signaturehelp.SignatureHelp.kt</ID>
    <ID>TooManyFunctions:SourceFiles.kt$SourceFiles</ID>
    <ID>TooManyFunctions:SourcePath.kt$SourcePath</ID>
    <ID>TooManyFunctions:SourcePath.kt$SourcePath$SourceFile</ID>
    <ID>UnusedPrivateMember:Completions.kt$private fun completeTypeMembers(type: KotlinType): Sequence&lt;DeclarationDescriptor&gt;</ID>
    <ID>UnusedPrivateMember:JavaElementConverter.kt$JavaElementConverter$private fun PsiCallExpression.translateTypeArguments(): String</ID>
    <ID>UnusedPrivateMember:Logger.kt$Logger$private val newline = System.lineSeparator()</ID>
    <ID>UnusedPrivateMember:SourceFiles.kt$i</ID>
    <ID>WildcardImport:AddMissingImportsQuickFix.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:CodeAction.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:CompiledFile.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:Compiler.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:Completions.kt$import org.jetbrains.kotlin.descriptors.*</ID>
    <ID>WildcardImport:Completions.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:Completions.kt$import org.jetbrains.kotlin.psi.psiUtil.*</ID>
    <ID>WildcardImport:Completions.kt$import org.jetbrains.kotlin.resolve.descriptorUtil.*</ID>
    <ID>WildcardImport:ExtractSymbolExtensionReceiverType.kt$import org.jetbrains.kotlin.descriptors.*</ID>
    <ID>WildcardImport:ExtractSymbolKind.kt$import org.jetbrains.kotlin.descriptors.*</ID>
    <ID>WildcardImport:ExtractSymbolVisibility.kt$import org.jetbrains.kotlin.descriptors.*</ID>
    <ID>WildcardImport:FindReferences.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:Hovers.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:ImplementAbstractMembersQuickFix.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:Imports.kt$import org.jetbrains.kotlin.psi.*</ID>
    <ID>WildcardImport:JavaElementConverter.kt$import com.intellij.psi.*</ID>
    <ID>WildcardImport:JavaElementConverter.kt$import com.intellij.psi.javadoc.*</ID>
    <ID>WildcardImport:JavaTypeConverter.kt$import com.intellij.psi.*</ID>
    <ID>WildcardImport:KotlinProtocolExtensionService.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:KotlinProtocolExtensions.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:KotlinTextDocumentService.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:KotlinWorkspaceService.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:Rename.kt$import org.eclipse.lsp4j.*</ID>
    <ID>WildcardImport:RenderCompletionItem.kt$import org.jetbrains.kotlin.descriptors.*</ID>
    <ID>WildcardImport:SymbolIndex.kt$import org.jetbrains.exposed.sql.*</ID>
    <ID>WildcardImport:Symbols.kt$import org.jetbrains.kotlin.psi.*</ID>
  </CurrentIssues>
</SmellBaseline>
